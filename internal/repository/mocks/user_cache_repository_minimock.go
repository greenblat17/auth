// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/greenblat17/auth/internal/repository.UserCacheRepository -o user_cache_repository_minimock.go -n UserCacheRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/greenblat17/auth/internal/model"
)

// UserCacheRepositoryMock implements mm_repository.UserCacheRepository
type UserCacheRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserCacheRepositoryMockDelete

	funcExpire          func(ctx context.Context, id int64, ttl time.Duration) (err error)
	funcExpireOrigin    string
	inspectFuncExpire   func(ctx context.Context, id int64, ttl time.Duration)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mUserCacheRepositoryMockExpire

	funcGet          func(ctx context.Context, id int64) (up1 *model.User, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserCacheRepositoryMockGet

	funcSet          func(ctx context.Context, user *model.User) (i1 int64, err error)
	funcSetOrigin    string
	inspectFuncSet   func(ctx context.Context, user *model.User)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mUserCacheRepositoryMockSet
}

// NewUserCacheRepositoryMock returns a mock for mm_repository.UserCacheRepository
func NewUserCacheRepositoryMock(t minimock.Tester) *UserCacheRepositoryMock {
	m := &UserCacheRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mUserCacheRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserCacheRepositoryMockDeleteParams{}

	m.ExpireMock = mUserCacheRepositoryMockExpire{mock: m}
	m.ExpireMock.callArgs = []*UserCacheRepositoryMockExpireParams{}

	m.GetMock = mUserCacheRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserCacheRepositoryMockGetParams{}

	m.SetMock = mUserCacheRepositoryMockSet{mock: m}
	m.SetMock.callArgs = []*UserCacheRepositoryMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCacheRepositoryMockDelete struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockDeleteExpectation
	expectations       []*UserCacheRepositoryMockDeleteExpectation

	callArgs []*UserCacheRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockDeleteExpectation specifies expectation struct of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockDeleteParams
	paramPtrs          *UserCacheRepositoryMockDeleteParamPtrs
	expectationOrigins UserCacheRepositoryMockDeleteExpectationOrigins
	results            *UserCacheRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockDeleteParams contains parameters of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserCacheRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheRepositoryMockDeleteResults contains results of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteResults struct {
	err error
}

// UserCacheRepositoryMockDeleteOrigins contains origins of expectations of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserCacheRepositoryMockDelete) Optional() *mUserCacheRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserCacheRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserCacheRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) ExpectIdParam2(id int64) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserCacheRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) Return(err error) *UserCacheRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserCacheRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UserCacheRepository.Delete method
func (mmDelete *mUserCacheRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserCacheRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UserCacheRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserCacheRepositoryMockDelete) When(ctx context.Context, id int64) *UserCacheRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UserCacheRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: UserCacheRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockDeleteExpectation) Then(err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Delete should be invoked
func (mmDelete *mUserCacheRepositoryMockDelete) Times(n uint64) *mUserCacheRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserCacheRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUserCacheRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.UserCacheRepository
func (mmDelete *UserCacheRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserCacheRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserCacheRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserCacheRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserCacheRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserCacheRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserCacheRepositoryMock.Delete invocations
func (mmDelete *UserCacheRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserCacheRepositoryMock.Delete invocations
func (mmDelete *UserCacheRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserCacheRepositoryMockDelete) Calls() []*UserCacheRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUserCacheRepositoryMockExpire struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockExpireExpectation
	expectations       []*UserCacheRepositoryMockExpireExpectation

	callArgs []*UserCacheRepositoryMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockExpireExpectation specifies expectation struct of the UserCacheRepository.Expire
type UserCacheRepositoryMockExpireExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockExpireParams
	paramPtrs          *UserCacheRepositoryMockExpireParamPtrs
	expectationOrigins UserCacheRepositoryMockExpireExpectationOrigins
	results            *UserCacheRepositoryMockExpireResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockExpireParams contains parameters of the UserCacheRepository.Expire
type UserCacheRepositoryMockExpireParams struct {
	ctx context.Context
	id  int64
	ttl time.Duration
}

// UserCacheRepositoryMockExpireParamPtrs contains pointers to parameters of the UserCacheRepository.Expire
type UserCacheRepositoryMockExpireParamPtrs struct {
	ctx *context.Context
	id  *int64
	ttl *time.Duration
}

// UserCacheRepositoryMockExpireResults contains results of the UserCacheRepository.Expire
type UserCacheRepositoryMockExpireResults struct {
	err error
}

// UserCacheRepositoryMockExpireOrigins contains origins of expectations of the UserCacheRepository.Expire
type UserCacheRepositoryMockExpireExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
	originTtl string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mUserCacheRepositoryMockExpire) Optional() *mUserCacheRepositoryMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for UserCacheRepository.Expire
func (mmExpire *mUserCacheRepositoryMockExpire) Expect(ctx context.Context, id int64, ttl time.Duration) *mUserCacheRepositoryMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &UserCacheRepositoryMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &UserCacheRepositoryMockExpireParams{ctx, id, ttl}
	mmExpire.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Expire
func (mmExpire *mUserCacheRepositoryMockExpire) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &UserCacheRepositoryMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &UserCacheRepositoryMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx
	mmExpire.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExpire
}

// ExpectIdParam2 sets up expected param id for UserCacheRepository.Expire
func (mmExpire *mUserCacheRepositoryMockExpire) ExpectIdParam2(id int64) *mUserCacheRepositoryMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &UserCacheRepositoryMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &UserCacheRepositoryMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.id = &id
	mmExpire.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmExpire
}

// ExpectTtlParam3 sets up expected param ttl for UserCacheRepository.Expire
func (mmExpire *mUserCacheRepositoryMockExpire) ExpectTtlParam3(ttl time.Duration) *mUserCacheRepositoryMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &UserCacheRepositoryMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &UserCacheRepositoryMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ttl = &ttl
	mmExpire.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Expire
func (mmExpire *mUserCacheRepositoryMockExpire) Inspect(f func(ctx context.Context, id int64, ttl time.Duration)) *mUserCacheRepositoryMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by UserCacheRepository.Expire
func (mmExpire *mUserCacheRepositoryMockExpire) Return(err error) *UserCacheRepositoryMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &UserCacheRepositoryMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &UserCacheRepositoryMockExpireResults{err}
	mmExpire.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// Set uses given function f to mock the UserCacheRepository.Expire method
func (mmExpire *mUserCacheRepositoryMockExpire) Set(f func(ctx context.Context, id int64, ttl time.Duration) (err error)) *UserCacheRepositoryMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Expire method")
	}

	mmExpire.mock.funcExpire = f
	mmExpire.mock.funcExpireOrigin = minimock.CallerInfo(1)
	return mmExpire.mock
}

// When sets expectation for the UserCacheRepository.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mUserCacheRepositoryMockExpire) When(ctx context.Context, id int64, ttl time.Duration) *UserCacheRepositoryMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("UserCacheRepositoryMock.Expire mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockExpireExpectation{
		mock:               mmExpire.mock,
		params:             &UserCacheRepositoryMockExpireParams{ctx, id, ttl},
		expectationOrigins: UserCacheRepositoryMockExpireExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Expire return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockExpireExpectation) Then(err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockExpireResults{err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Expire should be invoked
func (mmExpire *mUserCacheRepositoryMockExpire) Times(n uint64) *mUserCacheRepositoryMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of UserCacheRepositoryMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	mmExpire.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpire
}

func (mmExpire *mUserCacheRepositoryMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements mm_repository.UserCacheRepository
func (mmExpire *UserCacheRepositoryMock) Expire(ctx context.Context, id int64, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	mmExpire.t.Helper()

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, id, ttl)
	}

	mm_params := UserCacheRepositoryMockExpireParams{ctx, id, ttl}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockExpireParams{ctx, id, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("UserCacheRepositoryMock.Expire got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmExpire.t.Errorf("UserCacheRepositoryMock.Expire got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmExpire.t.Errorf("UserCacheRepositoryMock.Expire got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpire.ExpireMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("UserCacheRepositoryMock.Expire got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpire.ExpireMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the UserCacheRepositoryMock.Expire")
		}
		return (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, id, ttl)
	}
	mmExpire.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Expire. %v %v %v", ctx, id, ttl)
	return
}

// ExpireAfterCounter returns a count of finished UserCacheRepositoryMock.Expire invocations
func (mmExpire *UserCacheRepositoryMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of UserCacheRepositoryMock.Expire invocations
func (mmExpire *UserCacheRepositoryMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mUserCacheRepositoryMockExpire) Calls() []*UserCacheRepositoryMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Expire at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Expire at\n%s", m.ExpireMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Expire at\n%s with params: %#v", m.ExpireMock.defaultExpectation.expectationOrigins.origin, *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Expire at\n%s", m.funcExpireOrigin)
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Expire at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), m.ExpireMock.expectedInvocationsOrigin, afterExpireCounter)
	}
}

type mUserCacheRepositoryMockGet struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockGetExpectation
	expectations       []*UserCacheRepositoryMockGetExpectation

	callArgs []*UserCacheRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockGetExpectation specifies expectation struct of the UserCacheRepository.Get
type UserCacheRepositoryMockGetExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockGetParams
	paramPtrs          *UserCacheRepositoryMockGetParamPtrs
	expectationOrigins UserCacheRepositoryMockGetExpectationOrigins
	results            *UserCacheRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockGetParams contains parameters of the UserCacheRepository.Get
type UserCacheRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// UserCacheRepositoryMockGetParamPtrs contains pointers to parameters of the UserCacheRepository.Get
type UserCacheRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheRepositoryMockGetResults contains results of the UserCacheRepository.Get
type UserCacheRepositoryMockGetResults struct {
	up1 *model.User
	err error
}

// UserCacheRepositoryMockGetOrigins contains origins of expectations of the UserCacheRepository.Get
type UserCacheRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserCacheRepositoryMockGet) Optional() *mUserCacheRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) Expect(ctx context.Context, id int64) *mUserCacheRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserCacheRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserCacheRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) ExpectIdParam2(id int64) *mUserCacheRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserCacheRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserCacheRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) Return(up1 *model.User, err error) *UserCacheRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserCacheRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UserCacheRepository.Get method
func (mmGet *mUserCacheRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *UserCacheRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UserCacheRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserCacheRepositoryMockGet) When(ctx context.Context, id int64) *UserCacheRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UserCacheRepositoryMockGetParams{ctx, id},
		expectationOrigins: UserCacheRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockGetExpectation) Then(up1 *model.User, err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Get should be invoked
func (mmGet *mUserCacheRepositoryMockGet) Times(n uint64) *mUserCacheRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserCacheRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUserCacheRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.UserCacheRepository
func (mmGet *UserCacheRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserCacheRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserCacheRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserCacheRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserCacheRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserCacheRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserCacheRepositoryMock.Get invocations
func (mmGet *UserCacheRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserCacheRepositoryMock.Get invocations
func (mmGet *UserCacheRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserCacheRepositoryMockGet) Calls() []*UserCacheRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUserCacheRepositoryMockSet struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockSetExpectation
	expectations       []*UserCacheRepositoryMockSetExpectation

	callArgs []*UserCacheRepositoryMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockSetExpectation specifies expectation struct of the UserCacheRepository.Set
type UserCacheRepositoryMockSetExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockSetParams
	paramPtrs          *UserCacheRepositoryMockSetParamPtrs
	expectationOrigins UserCacheRepositoryMockSetExpectationOrigins
	results            *UserCacheRepositoryMockSetResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockSetParams contains parameters of the UserCacheRepository.Set
type UserCacheRepositoryMockSetParams struct {
	ctx  context.Context
	user *model.User
}

// UserCacheRepositoryMockSetParamPtrs contains pointers to parameters of the UserCacheRepository.Set
type UserCacheRepositoryMockSetParamPtrs struct {
	ctx  *context.Context
	user **model.User
}

// UserCacheRepositoryMockSetResults contains results of the UserCacheRepository.Set
type UserCacheRepositoryMockSetResults struct {
	i1  int64
	err error
}

// UserCacheRepositoryMockSetOrigins contains origins of expectations of the UserCacheRepository.Set
type UserCacheRepositoryMockSetExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mUserCacheRepositoryMockSet) Optional() *mUserCacheRepositoryMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for UserCacheRepository.Set
func (mmSet *mUserCacheRepositoryMockSet) Expect(ctx context.Context, user *model.User) *mUserCacheRepositoryMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheRepositoryMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &UserCacheRepositoryMockSetParams{ctx, user}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Set
func (mmSet *mUserCacheRepositoryMockSet) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheRepositoryMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &UserCacheRepositoryMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSet
}

// ExpectUserParam2 sets up expected param user for UserCacheRepository.Set
func (mmSet *mUserCacheRepositoryMockSet) ExpectUserParam2(user *model.User) *mUserCacheRepositoryMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheRepositoryMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &UserCacheRepositoryMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.user = &user
	mmSet.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Set
func (mmSet *mUserCacheRepositoryMockSet) Inspect(f func(ctx context.Context, user *model.User)) *mUserCacheRepositoryMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by UserCacheRepository.Set
func (mmSet *mUserCacheRepositoryMockSet) Return(i1 int64, err error) *UserCacheRepositoryMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheRepositoryMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &UserCacheRepositoryMockSetResults{i1, err}
	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the UserCacheRepository.Set method
func (mmSet *mUserCacheRepositoryMockSet) Set(f func(ctx context.Context, user *model.User) (i1 int64, err error)) *UserCacheRepositoryMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the UserCacheRepository.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mUserCacheRepositoryMockSet) When(ctx context.Context, user *model.User) *UserCacheRepositoryMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheRepositoryMock.Set mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockSetExpectation{
		mock:               mmSet.mock,
		params:             &UserCacheRepositoryMockSetParams{ctx, user},
		expectationOrigins: UserCacheRepositoryMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Set return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockSetExpectation) Then(i1 int64, err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockSetResults{i1, err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Set should be invoked
func (mmSet *mUserCacheRepositoryMockSet) Times(n uint64) *mUserCacheRepositoryMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of UserCacheRepositoryMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mUserCacheRepositoryMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_repository.UserCacheRepository
func (mmSet *UserCacheRepositoryMock) Set(ctx context.Context, user *model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, user)
	}

	mm_params := UserCacheRepositoryMockSetParams{ctx, user}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockSetParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("UserCacheRepositoryMock.Set got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSet.t.Errorf("UserCacheRepositoryMock.Set got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("UserCacheRepositoryMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the UserCacheRepositoryMock.Set")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, user)
	}
	mmSet.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Set. %v %v", ctx, user)
	return
}

// SetAfterCounter returns a count of finished UserCacheRepositoryMock.Set invocations
func (mmSet *UserCacheRepositoryMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of UserCacheRepositoryMock.Set invocations
func (mmSet *UserCacheRepositoryMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mUserCacheRepositoryMockSet) Calls() []*UserCacheRepositoryMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCacheRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteInspect()

			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCacheRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCacheRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockSetDone()
}
